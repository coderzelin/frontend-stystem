### HTTP

HTTP 是一种超文本协议，它是无状态的协议，也就是一次请求响应之后，服务器不会记住客户端的状态。

#### HTTP 0.9

最早诞生的 HTTP 0.9 主要用来传输超文本 HTML，用于学术交流，它的实现很简单，就是基于请求响应的模式，从客户端发出请求，服务器返回数据。只有请求行，并且是通过 ASCLL 字节码传输

![image](https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png)

#### HTTP 1.0

随着万维网的发展，浏览器不仅只展示 HTML 文件，需要处理 javascript、css、图片、音频、视频等文件，因此 HTTP 1.0 需要支持多种文件类型的下载，HTTP 1.0 引入了请求头和响应头。在支持多种文件类型的基础上，还提供了 Cache 机制，用户代理，响应码等信息

![image](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png)

#### HTTP 1.1

在 HTTP 1.0 中没进行一次 HTTP 通信，都需要进行 TCP 连接和断开，所以 HTTP 1.1 引入了持久连接，减少大量 TCP 连接断开的开销，HTTP 1.1 默认开启持久连接，只要浏览器或服务器没有明确断开，TCP 连接就不会断开。浏览器中对于一个域名，最多可以有6个 TCP 持久连接

![image](https://static001.geekbang.org/resource/image/80/1a/80b57830e15faa17631bea74054a0e1a.png)

在一个 TCP 连接中，如果有一个请求挂掉，就会阻塞后面的请求，这就是队头阻塞问题。为了解决这个问题，在 HTTP 1.1 试图通过管线化技术解决，管线化指的是多个 HTTP 请求批量发送给服务器，服务器按顺序返回。由于各种原因，最终放弃了管线化技术

除此之外，HTTP 1.1 还引入了 Cookie、虚拟主机，动态内容的支持等特性

---

### HTTP 2.0

HTTP 1.1 的主要问题是对带宽的利用率不高，带宽指的是每秒最大能发送和接送的字节数。有三个原因影响到：

- TCP 慢启动
- 多个 TCP 连接竞争有限的带宽
- 队头阻塞

HTTP 2.0 主要思路是一个域名只使用一个 TCP 长连接传输数据，这样整个页面就只需要一次慢启动，也不会有多个 TCP 连接之间竞争带宽。**HTTP 2.0 最核心，最重要且最颠覆性的机制是多路复用机制**

![image](https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg)

多路复用的实现

![image](https://static001.geekbang.org/resource/image/86/6a/86cdf01a3af7f4f755d28917e58aae6a.png)

HTTP 2.0 添加了一个二进制分帧层，请求和接受过程如下:

- 浏览器准备好请求数据，包括请求行，请求头，如果是 post 方法那么还有请求体
- 这些数据通过二进制分帧层，会被转换成一个个带有 ID 的帧，这些帧通过协议栈发送给服务器
- 服务器接收到所有帧之后，会把同样 ID 的帧组合成一个完整的请求
- 然后服务器处理这条请求，并把处理好的响应行，响应头，响应体发送给二进制分帧层
- 二进制分帧层把这些响应数据转换为一个个带有 ID 的帧，经过协议栈发送给浏览器
- 浏览器把响应帧，把同样 ID 的帧组合成一个完整的响应信息

二级制分帧层还能实现请求的优先级，服务器推送，头部压缩等特性

---

### HTTP 3.0

因为 HTTP 2.0 是基于 TCP 协议的，所以还存在 TCP 队头阻塞，建立 TCP 连接的延迟、TCP 协议僵化问题

#### TCP 队头阻塞

TCP 最初的设计就是为了单连接，TCP 连接可以想象成两台计算机的一个虚拟管道，计算机一段将数据按顺序放入管道，最终数据会以相同数据出现在另外一头

如果传输的过程中有一个数据包因为网络故障丢包了，整个 TCP 连接就会处于暂停状态，需要等待丢失的数据包重新传输过来

![image](https://static001.geekbang.org/resource/image/33/96/33d2b4c14a7a2f19ef6677696b67de96.png)

HTTP 2.0中，多个请求是跑在一个 TCP 管道中，如果有一路数据流丢包，就会阻塞该 TCP 连接中的所有请求

![image](https://static001.geekbang.org/resource/image/48/d1/4837434655a6d87f1bf5e3d899a698d1.png)

#### TCP 建立连接的延时

网络延迟又称为 RTT（Round Trip Time）我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标

![image](https://static001.geekbang.org/resource/image/e9/4f/e98927e19b20349815fb8f499067cb4f.png)

TCP 连接三次握手，TLS 握手延迟时间大概需要花掉 3-4 个 RTT，如果浏览器和服务器的物理距离较远，整个握手过程需要 300 - 400 毫秒

#### TCP 协议僵化

中间设备的僵化，操作系统导致 TCP 协议僵化，所以很难更新 TCP 协议

#### QUIC 协议

基于 UDP 实现了类似 TCP 的多路数据流，传输可靠性等功能的协议

![image](https://static001.geekbang.org/resource/image/0b/c6/0bae470bb49747b9a59f9f4bb496a9c6.png)

HTTP 3.0 使用了 QUIC 协议集合了以下功能：

- 实现了类似 TCP 的流量控制，传输可靠性的功能

- 集成了 TLS 加密功能

- 实现了 HTTP 2.0 的多路复用功能，解决了队头阻塞问题

  ![image](https://static001.geekbang.org/resource/image/05/9a/05cc5720989aec75730ee4cb7e7c149a.png)

- 实现了快速握手功能

---

### HTTPS

因为 HTTP 是明文传输的，在传输的过程中，数据有可能被窃取或者篡改，使用 HTTP 传输的内容很容易被中间人窃取，伪造和篡改，通常把这种攻击称为**中间人攻击**

![image](https://static001.geekbang.org/resource/image/11/e2/118ced11537bd1e257f8df09380f33e2.png)

HTTPS 就是在 HTTP 和 TCP 之间插入一个安全层，安全层的职责就是对发起的 HTTP 请求的数据进行加密操作和对接收到的 HTTP 的内容进行解密操作

![image](https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png)

#### 第一版：使用对称加密

对称加密是指加密和解密都使用相同的密钥，过程如下

![image](https://static001.geekbang.org/resource/image/d8/3b/d86648267d5504c7813b2d692620503b.png)

因为传输过程中的 client-random 和 service-random 的过程是明文的，意味着黑客也可以拿到协商的加密套件和随机数，然后合成密钥，数据也可以被破解

#### 第二版：使用非对称加密

非对称加密算法有 A、B 两把密钥，如果 A 密钥来加密，那么只能使用 B 密钥来解密。反过来，如果用 B 密钥来加密，那么只能用 A 密钥来解密

HTTPS 过程中，服务器会将公钥明文发给浏览器，会把私钥自己留下，公钥每个人都可以获取到，私钥只有服务器知道，不对任何人公开

![image](https://static001.geekbang.org/resource/image/b2/50/b2b893921491c62b29aaddc1d4fa9550.png)

采用非对称加密，能保证浏览器发给服务器的数据是安全的，但还是有两个问题：

- 非对称加密效率太低，严重影响到加解密数据的速度，从而影响到用户打开页面的速度
- 无法保证服务器发送给浏览器的数据安全，因为服务器只能采用私钥加密，而公钥能被黑客获取到，所以可以用公钥解密数据

#### 第三版：对称加密 + 非对称加密

在传输数据时候使用对称加密，但是对称加密的密钥使用非对称加密来传输

![image](https://static001.geekbang.org/resource/image/d5/45/d5cd34dbf3636ebc0e809aa424c53845.png)

重点在于 pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程的数据了

#### 第四版：添加数字证书

通过权威认证结构 CA 颁发数字证书，数字证书的作用：

- 通过数字证书证明服务器的身份
- 数字证书里面包含服务器公钥

![image](https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png)

有两点改变了：

1. 服务器没有返回公钥，而是返回了数字证书，公钥包含在数字证书中
2. 在浏览器端多了一个验证证书的操作，验证通过了之后，才继续后续流程

#### 如何申请数字证书

- 准备一套私钥和公钥，私钥自己留着
- 向 CA 机构提供公钥，公司，站点等信息并等待认证，这个认证过程可能收费
- CA 通过各种渠道验证信息的真实性
- 审核通过后，CA 会向站点签发数字证书，包含各种信息，都是明文的，同时包含一个数字签名

数字签名：首先 CA 使用 Hash 函数来计算站点提交的明文信息，并得出信息摘要，然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是数字签名，相当于在上面盖个章，这个章可以去验证的

#### 浏览器如何验证数字证书

浏览器接收到服务器返回的数字证书。首先会读取证书中的明文信息，采用 CA 签名相同的 Hash 函数来计算得到信息摘要 A，然后利用CA 的公钥解密签名数据，得到信息摘要 B，对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的。

---

### TCP & UDP

#### UDP特点

UDP 面向非连接，不可靠，不保证不丢失，不保证按顺序到达，没有拥塞机制，不会根据网络环境调整发送的速度，可以广播

![image](https://static001.geekbang.org/resource/image/2c/84/2c9a109f3be308dea901004a5a3b4c84.jpg)

#### UDP 使用场景

- 需要资源少，在网络比较好的内网，对于丢包不敏感的应用
- 不需要一对一沟通，建立连接，可以广播的应用
- 需要处理速度快，时延低，可以容忍少数丢包，要求即便网络拥塞，也毫不退缩



